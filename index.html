import React, { useState, useRef, useEffect } from 'react';
import { Card, CardHeader, CardTitle, CardContent } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Upload, Save, Undo, ChevronLeft, ChevronRight } from 'lucide-react';

const ImageAnnotator = () => {
  const [images, setImages] = useState([]);
  const [currentImageIndex, setCurrentImageIndex] = useState(0);
  const [points, setPoints] = useState({});  // 用物件來儲存每張圖片的點
  const canvasRef = useRef(null);

  const handleFolderUpload = (event) => {
    const files = Array.from(event.target.files).filter(file => 
      file.type.startsWith('image/')
    );

    Promise.all(files.map(file => {
      return new Promise((resolve) => {
        const reader = new FileReader();
        reader.onload = (e) => {
          const img = new Image();
          img.onload = () => {
            resolve({
              file: file,
              img: img,
              name: file.name
            });
          };
          img.src = e.target.result;
        };
        reader.readAsDataURL(file);
      });
    })).then(loadedImages => {
      setImages(loadedImages);
      setPoints(loadedImages.reduce((acc, img) => {
        acc[img.name] = [];
        return acc;
      }, {}));
      setCurrentImageIndex(0);
    });
  };

  const getCurrentImage = () => {
    return images[currentImageIndex]?.img;
  };

  const getCurrentImageName = () => {
    return images[currentImageIndex]?.name;
  };

  const drawImage = () => {
    const currentImage = getCurrentImage();
    if (!currentImage) return;

    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    canvas.width = currentImage.width;
    canvas.height = currentImage.height;
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.drawImage(currentImage, 0, 0);
    
    const currentPoints = points[getCurrentImageName()] || [];
    if (currentPoints.length > 0) {
      ctx.beginPath();
      ctx.moveTo(currentPoints[0].x, currentPoints[0].y);
      currentPoints.forEach((point, index) => {
        if (index > 0) {
          ctx.lineTo(point.x, point.y);
        }
      });
      if (currentPoints.length > 2) {
        ctx.closePath();
      }
      ctx.strokeStyle = '#00ff00';
      ctx.lineWidth = 2;
      ctx.stroke();
    }
  };

  const handleCanvasClick = (event) => {
    const currentImage = getCurrentImage();
    if (!currentImage) return;
    
    const rect = canvasRef.current.getBoundingClientRect();
    const x = event.clientX - rect.left;
    const y = event.clientY - rect.top;
    
    const imageName = getCurrentImageName();
    const currentPoints = [...(points[imageName] || [])];
    currentPoints.push({ x, y });
    setPoints({ ...points, [imageName]: currentPoints });
  };

  const handleUndo = () => {
    const imageName = getCurrentImageName();
    const currentPoints = points[imageName] || [];
    if (currentPoints.length > 0) {
      const newPoints = currentPoints.slice(0, -1);
      setPoints({ ...points, [imageName]: newPoints });
    }
  };

  const handleSaveAll = () => {
    const annotations = {};
    
    images.forEach(image => {
      const imagePoints = points[image.name] || [];
      if (imagePoints.length >= 3) {
        annotations[image.name] = {
          version: "5.0.1",
          flags: {},
          shapes: [
            {
              label: "spine",
              points: imagePoints.map(p => [p.x, p.y]),
              group_id: null,
              shape_type: "polygon",
              flags: {}
            }
          ],
          imagePath: image.name,
          imageHeight: image.img.height,
          imageWidth: image.img.width
        };
      }
    });

    // 建立包含所有標註的 ZIP 檔案
    const zip = new JSZip();
    Object.entries(annotations).forEach(([filename, data]) => {
      zip.file(`${filename.split('.')[0]}.json`, JSON.stringify(data, null, 2));
    });

    zip.generateAsync({ type: "blob" }).then(blob => {
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'annotations.zip';
      a.click();
      URL.revokeObjectURL(url);
    });
  };

  const navigateImage = (direction) => {
    const newIndex = currentImageIndex + direction;
    if (newIndex >= 0 && newIndex < images.length) {
      setCurrentImageIndex(newIndex);
    }
  };

  useEffect(() => {
    drawImage();
  }, [currentImageIndex, points]);

  return (
    <Card className="w-full max-w-4xl mx-auto my-4">
      <CardHeader>
        <CardTitle>資料夾圖像標註工具</CardTitle>
      </CardHeader>
      <CardContent>
        <div className="flex flex-col gap-4">
          <div className="flex gap-4">
            <Button className="flex items-center gap-2" onClick={() => document.getElementById('folderInput').click()}>
              <Upload size={16} />
              上傳資料夾
            </Button>
            <Button className="flex items-center gap-2" onClick={handleUndo} disabled={!getCurrentImage()}>
              <Undo size={16} />
              復原
            </Button>
            <Button className="flex items-center gap-2" onClick={handleSaveAll} disabled={images.length === 0}>
              <Save size={16} />
              儲存全部
            </Button>
          </div>
          
          <input
            id="folderInput"
            type="file"
            webkitdirectory="true"
            directory="true"
            multiple
            onChange={handleFolderUpload}
            className="hidden"
          />

          {getCurrentImage() && (
            <div className="flex items-center justify-between mb-2">
              <Button onClick={() => navigateImage(-1)} disabled={currentImageIndex === 0}>
                <ChevronLeft size={16} />
              </Button>
              <span className="text-sm">
                {getCurrentImageName()} ({currentImageIndex + 1} / {images.length})
              </span>
              <Button onClick={() => navigateImage(1)} disabled={currentImageIndex === images.length - 1}>
                <ChevronRight size={16} />
              </Button>
            </div>
          )}

          <div className="relative border rounded-lg overflow-hidden">
            <canvas
              ref={canvasRef}
              onClick={handleCanvasClick}
              className="cursor-crosshair"
              style={{ maxWidth: '100%', height: 'auto' }}
            />
          </div>
        </div>
      </CardContent>
    </Card>
  );
};

export default ImageAnnotator;