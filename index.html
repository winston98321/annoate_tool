<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>é€²éšåœ–åƒæ¨™è¨»å·¥å…·</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        .controls {
            margin-bottom: 20px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        button {
            padding: 10px 20px;
            cursor: pointer;
            background-color: #f0f0f0;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        button.active {
            background-color: #4CAF50;
            color: white;
        }
        .canvas-container {
            position: relative;
            border: 1px solid #ccc;
            margin-top: 20px;
        }
        canvas {
            max-width: 100%;
            height: auto;
            cursor: crosshair;
        }
        canvas.eraser {
            cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" style="font-size: 20px;"><text y="18">ğŸ—‘ï¸</text></svg>'), auto;
        }

        .navigation {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin: 10px 0;
        }
        .polygon-list {
            margin-top: 10px;
            padding: 10px;
            background: #f5f5f5;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <div class="controls">
        <button onclick="document.getElementById('folderInput').click()">ä¸Šå‚³è³‡æ–™å¤¾</button>
        <button onclick="toggleTool('polygon')" id="polygonBtn">ç¹ªè£½å¤šé‚Šå½¢</button>
        <button onclick="toggleTool('eraser')" id="eraserBtn">æ“¦é™¤</button>
        <button onclick="finishPolygon()" id="finishBtn" disabled>å®Œæˆå¤šé‚Šå½¢</button>
        <button onclick="handleUndo()" id="undoBtn" disabled>å¾©åŸ</button>
        <button onclick="handleSaveAll()" id="saveBtn" disabled>å„²å­˜å…¨éƒ¨</button>
        <input type="file" id="folderInput" webkitdirectory directory multiple style="display:none" onchange="handleFolderUpload(event)">
    </div>
    
    <div class="navigation">
        <button onclick="navigateImage(-1)" id="prevBtn" disabled>ä¸Šä¸€å¼µ</button>
        <span id="imageInfo"></span>
        <button onclick="navigateImage(1)" id="nextBtn" disabled>ä¸‹ä¸€å¼µ</button>
    </div>

    <div class="canvas-container">
        <canvas id="canvas"></canvas>
    </div>
    
    <div class="polygon-list" id="polygonList">
        <h3>å¤šé‚Šå½¢æ¸…å–®</h3>
        <div id="polygonListContent"></div>
    </div>

    <script>
        let images = [];
        let currentImageIndex = 0;
        let imageAnnotations = {};  // å„²å­˜æ¯å¼µåœ–ç‰‡çš„æ‰€æœ‰å¤šé‚Šå½¢
        let currentPoints = [];     // ç›®å‰æ­£åœ¨ç¹ªè£½çš„å¤šé‚Šå½¢çš„é»
        let currentTool = 'polygon';
        let isDrawing = false;

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        document.addEventListener('keydown', function(event) {
            if (event.ctrlKey && event.key === 'z') { 
                // Ctrl + Z: å¾©åŸ
                event.preventDefault();
                handleUndo();
            } else if (event.ctrlKey && event.key === 'a') { 
                // Ctrl + A: å®Œæˆå¤šé‚Šå½¢
                event.preventDefault();
                finishPolygon();
            } else if (event.key === 'ArrowLeft') {
                // å·¦æ–¹å‘éµ - ä¸Šä¸€å¼µåœ–ç‰‡
                navigateImage(-1);
            } else if (event.key === 'ArrowRight') {
                // å³æ–¹å‘éµ - ä¸‹ä¸€å¼µåœ–ç‰‡
                navigateImage(1);
            }
        });

        function toggleTool(tool) {
            currentTool = tool;
            document.getElementById('polygonBtn').classList.toggle('active', tool === 'polygon');
            document.getElementById('eraserBtn').classList.toggle('active', tool === 'eraser');
            canvas.classList.toggle('eraser', tool === 'eraser');
        }

        function handleFolderUpload(event) {
            const files = Array.from(event.target.files).filter(file => 
                file.type.startsWith('image/')
            );

            Promise.all(files.map(file => {
                return new Promise((resolve) => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const img = new Image();
                        img.onload = () => {
                            resolve({
                                file: file,
                                img: img,
                                name: file.name
                            });
                        };
                        img.src = e.target.result;
                    };
                    reader.readAsDataURL(file);
                });
            })).then(loadedImages => {
                images = loadedImages;
                imageAnnotations = loadedImages.reduce((acc, img) => {
                    acc[img.name] = [];
                    return acc;
                }, {});
                currentImageIndex = 0;
                updateUI();
                drawImage();
            });
        }

        function getCurrentImage() {
            return images[currentImageIndex]?.img;
        }

        function getCurrentImageName() {
            return images[currentImageIndex]?.name;
        }

        function drawImage() {
            const currentImage = getCurrentImage();
            if (!currentImage) return;

            canvas.width = currentImage.width;
            canvas.height = currentImage.height;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(currentImage, 0, 0);
            
            // ç¹ªè£½å·²å®Œæˆçš„å¤šé‚Šå½¢
            const currentAnnotations = imageAnnotations[getCurrentImageName()] || [];
            currentAnnotations.forEach((polygon, index) => {
                ctx.beginPath();
                ctx.moveTo(polygon[0].x, polygon[0].y);
                polygon.forEach((point, i) => {
                    if (i > 0) ctx.lineTo(point.x, point.y);
                });
                ctx.closePath();
                ctx.strokeStyle = '#00ff00';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // ç¹ªè£½å¤šé‚Šå½¢ç·¨è™Ÿ
                const centerX = polygon.reduce((sum, p) => sum + p.x, 0) / polygon.length;
                const centerY = polygon.reduce((sum, p) => sum + p.y, 0) / polygon.length;
                ctx.fillStyle = '#00ff00';
                ctx.font = '16px Arial';
                ctx.fillText(index + 1, centerX, centerY);
            });
            
            // ç¹ªè£½æ­£åœ¨ç¹ªè£½çš„å¤šé‚Šå½¢
            if (currentPoints.length > 0) {
                ctx.beginPath();
                ctx.moveTo(currentPoints[0].x, currentPoints[0].y);
                currentPoints.forEach((point, index) => {
                    if (index > 0) ctx.lineTo(point.x, point.y);
                });
                ctx.strokeStyle = '#ff0000';
                ctx.lineWidth = 2;
                ctx.stroke();
            }

            updatePolygonList();
        }

        function updatePolygonList() {
            const list = document.getElementById('polygonListContent');
            const currentAnnotations = imageAnnotations[getCurrentImageName()] || [];
            list.innerHTML = currentAnnotations.map((polygon, index) => 
                `<div>
                    å¤šé‚Šå½¢ ${index + 1}: ${polygon.length} å€‹é ‚é»
                    <button onclick="deletePolygon(${index})">åˆªé™¤</button>
                </div>`
            ).join('');
        }

        function deletePolygon(index) {
            const imageName = getCurrentImageName();
            if (imageAnnotations[imageName]) {
                imageAnnotations[imageName].splice(index, 1);
                drawImage();
            }
        }

        canvas.addEventListener('click', function(event) {
            if (!getCurrentImage()) return;

            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = (event.clientX - rect.left) * scaleX;
            const y = (event.clientY - rect.top) * scaleY;

            if (currentTool === 'polygon') {
                if (currentPoints.length > 0) {
                    // æª¢æŸ¥æ˜¯å¦æ¥è¿‘ç¬¬ä¸€å€‹é»ï¼ˆç¯„åœå…§è‡ªå‹•é–‰åˆï¼‰
                    const firstPoint = currentPoints[0];
                    const distance = Math.sqrt(
                        Math.pow(x - firstPoint.x, 2) + Math.pow(y - firstPoint.y, 2)
                    );
                    if (distance < 10) {
                        // è·é›¢å°æ–¼ 10pxï¼Œè‡ªå‹•é€£æ¥åˆ°ç¬¬ä¸€å€‹é»ä¸¦å®Œæˆå¤šé‚Šå½¢
                        finishPolygon();
                        return;
                    }
                }

                // æ­£å¸¸æ–°å¢é»
                currentPoints.push({ x, y });
                document.getElementById('finishBtn').disabled = currentPoints.length < 3;
                drawImage();
            } else if (currentTool === 'eraser') {
                const imageName = getCurrentImageName();
                const annotations = imageAnnotations[imageName];
                if (annotations) {
                    // æª¢æŸ¥é»æ“Šæ˜¯å¦åœ¨ä»»ä½•å¤šé‚Šå½¢å…§
                    for (let i = annotations.length - 1; i >= 0; i--) {
                        if (isPointInPolygon({ x, y }, annotations[i])) {
                            annotations.splice(i, 1);
                            break;
                        }
                    }
                    drawImage();
                }
            }
        });


        function isPointInPolygon(point, polygon) {
            let inside = false;
            for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                const xi = polygon[i].x, yi = polygon[i].y;
                const xj = polygon[j].x, yj = polygon[j].y;
                
                const intersect = ((yi > point.y) !== (yj > point.y))
                    && (point.x < (xj - xi) * (point.y - yi) / (yj - yi) + xi);
                if (intersect) inside = !inside;
            }
            return inside;
        }

        function finishPolygon() {
            if (currentPoints.length >= 3) {
                const imageName = getCurrentImageName();
                if (!imageAnnotations[imageName]) {
                    imageAnnotations[imageName] = [];
                }
                imageAnnotations[imageName].push([...currentPoints]);
                currentPoints = [];
                document.getElementById('finishBtn').disabled = true;
                drawImage();
            }
        }

        function handleUndo() {
            if (currentPoints.length > 0) {
                currentPoints.pop();
                document.getElementById('finishBtn').disabled = currentPoints.length < 3;
                drawImage();
            } else {
                const imageName = getCurrentImageName();
                const annotations = imageAnnotations[imageName];
                if (annotations && annotations.length > 0) {
                    annotations.pop();
                    drawImage();
                }
            }
        }

        async function handleSaveAll() {
            const zip = new JSZip();
            
            images.forEach(image => {
                const annotations = imageAnnotations[image.name] || [];
                if (annotations.length > 0) {
                    const labelmeFormat = {
                        version: "5.0.1",
                        flags: {},
                        shapes: annotations.map((polygon, index) => ({
                            label: `spine`,
                            points: polygon.map(p => [p.x, p.y]),
                            group_id: null,
                            shape_type: "polygon",
                            flags: {}
                        })),
                        imagePath: image.name,
                        imageHeight: image.img.height,
                        imageWidth: image.img.width
                    };
                    zip.file(`${image.name.split('.')[0]}.json`, JSON.stringify(labelmeFormat, null, 2));
                }
            });

            const blob = await zip.generateAsync({ type: "blob" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'annotations.zip';
            a.click();
            URL.revokeObjectURL(url);
        }

        function navigateImage(direction) {
            const newIndex = currentImageIndex + direction;
            if (newIndex >= 0 && newIndex < images.length) {
                currentPoints = [];  // åˆ‡æ›åœ–ç‰‡æ™‚æ¸…é™¤ç•¶å‰ç¹ªè£½çš„é»
                currentImageIndex = newIndex;
                drawImage();
                updateUI();
            }
        }

        function updateUI() {
            const hasImages = images.length > 0;
            document.getElementById('undoBtn').disabled = !hasImages;
            document.getElementById('saveBtn').disabled = !hasImages;
            document.getElementById('prevBtn').disabled = currentImageIndex === 0;
            document.getElementById('nextBtn').disabled = currentImageIndex === images.length - 1;
            document.getElementById('finishBtn').disabled = currentPoints.length < 3;
            
            if (hasImages) {
                document.getElementById('imageInfo').textContent = 
                    `${getCurrentImageName()} (${currentImageIndex + 1} / ${images.length})`;
            } else {
                document.getElementById('imageInfo').textContent = '';
            }
        }

        // åˆå§‹åŒ–å·¥å…·ç‹€æ…‹
        toggleTool('polygon');
    </script>
</body>
</html>