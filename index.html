<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>é€²éšåœ–åƒæ¨™è¨»å·¥å…·</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        .controls {
            margin-bottom: 20px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        button {
            padding: 10px 20px;
            cursor: pointer;
            background-color: #f0f0f0;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        button.active {
            background-color: #4CAF50;
            color: white;
        }
        .canvas-container {
            position: relative;
            border: 1px solid #ccc;
            margin-top: 20px;
        }
        canvas {
            max-width: 100%;
            height: auto;
            cursor: crosshair;
        }
        canvas.eraser {
            cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" style="font-size: 20px;"><text y="18">ğŸ—‘ï¸</text></svg>'), auto;
        }

        .navigation {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin: 10px 0;
        }
        .polygon-list {
            margin-top: 10px;
            padding: 10px;
            background: #f5f5f5;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <div class="controls">
        <button onclick="document.getElementById('folderInput').click()">ä¸Šå‚³è³‡æ–™å¤¾</button>
        <button onclick="toggleTool('hexagon')" id="hexagonBtn">ç¹ªè£½å…­é‚Šå½¢</button>
        <button onclick="toggleTool('polygon')" id="polygonBtn">ç¹ªè£½å¤šé‚Šå½¢</button>
        <button onclick="toggleTool('eraser')" id="eraserBtn">æ“¦é™¤</button>
        <button onclick="finishPolygon()" id="finishBtn" disabled>å®Œæˆå¤šé‚Šå½¢</button>
        <button onclick="handleUndo()" id="undoBtn" disabled>å¾©åŸ</button>
        <button onclick="handleSaveAll()" id="saveBtn" disabled>å„²å­˜å…¨éƒ¨</button>
        <input type="file" id="folderInput" webkitdirectory directory multiple style="display:none" onchange="handleFolderUpload(event)">
    </div>
    
    <div class="navigation">
        <button onclick="navigateImage(-1)" id="prevBtn" disabled>ä¸Šä¸€å¼µ</button>
        <span id="imageInfo"></span>
        <button onclick="navigateImage(1)" id="nextBtn" disabled>ä¸‹ä¸€å¼µ</button>
    </div>

    <div class="canvas-container">
        <canvas id="canvas"></canvas>
    </div>
    
    <div class="polygon-list" id="polygonList">
        <h3>å¤šé‚Šå½¢æ¸…å–®</h3>
        <div id="polygonListContent"></div>
    </div>

    <script>
        let images = [];
        let currentImageIndex = 0;
        let imageAnnotations = {};  // å„²å­˜æ¯å¼µåœ–ç‰‡çš„æ‰€æœ‰å¤šé‚Šå½¢
        let currentPoints = [];     // ç›®å‰æ­£åœ¨ç¹ªè£½çš„å¤šé‚Šå½¢çš„é»
        let currentTool = 'polygon';
        let isDrawing = false;
        let imageLoadQueue = []; // å¾…è¼‰å…¥çš„åœ–ç‰‡ä½‡åˆ—
        let isLoadingImages = false; // æ˜¯å¦æ­£åœ¨è¼‰å…¥åœ–ç‰‡


        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        document.addEventListener('keydown', function(event) {
            if (event.ctrlKey && event.key === 'z') { 
                // Ctrl + Z: å¾©åŸ
                event.preventDefault();
                handleUndo();
            } else if (event.ctrlKey && event.key === 'a') { 
                // Ctrl + A: å®Œæˆå¤šé‚Šå½¢
                event.preventDefault();
                finishPolygon();
            } else if (event.key === 'ArrowLeft') {
                // å·¦æ–¹å‘éµ - ä¸Šä¸€å¼µåœ–ç‰‡
                navigateImage(-1);
            } else if (event.key === 'ArrowRight') {
                // å³æ–¹å‘éµ - ä¸‹ä¸€å¼µåœ–ç‰‡
                navigateImage(1);
            }
        });

        function toggleTool(tool) {
            currentTool = tool;
            document.getElementById('polygonBtn').classList.toggle('active', tool === 'polygon');
            document.getElementById('hexagonBtn').classList.toggle('active', tool === 'hexagon'); // æ–°å¢å…­é‚Šå½¢æŒ‰éˆ•
            document.getElementById('eraserBtn').classList.toggle('active', tool === 'eraser');
            canvas.classList.toggle('eraser', tool === 'eraser');
        }

        async function handleFolderUpload(event) {
            // å°‡æ‰€æœ‰åœ–ç‰‡æª”æ¡ˆåŠ å…¥ä½‡åˆ—
            imageLoadQueue = Array.from(event.target.files).filter(file => 
                file.type.startsWith('image/')
            );
            
            // é‡ç½®ç›¸é—œè®Šæ•¸
            images = [];
            currentImageIndex = 0;
            imageAnnotations = {};
            isLoadingImages = true;
            
            // å»ºç«‹é€²åº¦é¡¯ç¤ºå…ƒç´ 
            const progressDiv = document.createElement('div');
            progressDiv.id = 'loadingProgress';
            progressDiv.style.margin = '10px 0';
            document.querySelector('.controls').appendChild(progressDiv);
            
            // é–‹å§‹è¼‰å…¥ç¬¬ä¸€å¼µåœ–ç‰‡
            await loadNextImage();
        }

        async function loadNextImage() {
            if (imageLoadQueue.length === 0) {
                isLoadingImages = false;
                const progressDiv = document.getElementById('loadingProgress');
                if (progressDiv) progressDiv.remove();
                updateUI();
                return;
            }
            
            const file = imageLoadQueue.shift();
            const progressDiv = document.getElementById('loadingProgress');
            progressDiv.textContent = `æ­£åœ¨è¼‰å…¥: ${file.name} (${images.length + 1}/${images.length + 1 + imageLoadQueue.length})`;
            
            try {
                const imgData = await loadSingleImage(file);
                images.push(imgData);
                imageAnnotations[imgData.name] = [];
                
                // å¦‚æœé€™æ˜¯ç¬¬ä¸€å¼µåœ–ç‰‡ï¼Œç«‹å³é¡¯ç¤º
                if (images.length === 1) {
                    drawImage();
                    updateUI();
                }
                
                // ç¹¼çºŒè¼‰å…¥ä¸‹ä¸€å¼µ
                await loadNextImage();
            } catch (error) {
                console.error(`Error loading image ${file.name}:`, error);
                await loadNextImage(); // è·³ééŒ¯èª¤çš„åœ–ç‰‡ç¹¼çºŒè¼‰å…¥
            }
        }

        function loadSingleImage(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => resolve({
                        file: file,
                        img: img,
                        name: file.name
                    });
                    img.onerror = () => reject(new Error(`Failed to load image: ${file.name}`));
                    img.src = e.target.result;
                };
                reader.onerror = () => reject(new Error(`Failed to read file: ${file.name}`));
                reader.readAsDataURL(file);
            });
        }

        function getCurrentImage() {
            return images[currentImageIndex]?.img;
        }

        function getCurrentImageName() {
            return images[currentImageIndex]?.name;
        }

        function drawImage() {
            const currentImage = getCurrentImage();
            if (!currentImage) return;

            // è®¾ç½®ç”»å¸ƒå¤§å°
            canvas.width = currentImage.width;
            canvas.height = currentImage.height;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(currentImage, 0, 0);

            // è°ƒè¯•è¾“å‡ºï¼šæ£€æŸ¥ç”»å¸ƒå’Œä¸Šä¸‹æ–‡
            console.log("Canvas size:", canvas.width, canvas.height);
            console.log("Annotations:", imageAnnotations[getCurrentImageName()]);
            console.log("Current points:", currentPoints);

            // ç»˜åˆ¶å·²å®Œæˆçš„å¤šè¾¹å½¢
            const currentAnnotations = imageAnnotations[getCurrentImageName()] || [];
            currentAnnotations.forEach((polygon, index) => {
                if (polygon.length < 2) return; // ç¡®ä¿è‡³å°‘æœ‰ä¸¤ä¸ªç‚¹
                ctx.beginPath();
                ctx.moveTo(polygon[0].x, polygon[0].y);
                polygon.forEach((point, i) => {
                    if (i > 0) ctx.lineTo(point.x, point.y);
                });
                ctx.closePath();
                ctx.strokeStyle = '#00ff00'; // ç»¿è‰²è¾¹çº¿
                ctx.lineWidth = 2; // è¾¹çº¿å®½åº¦
                ctx.stroke();

                // ç»˜åˆ¶æ¯ä¸ªç‚¹
                polygon.forEach((point, i) => {
                    // æ ‡æ³¨ç‚¹çš„ä½ç½®
                    ctx.fillStyle = '#ff0000'; // ç‚¹çš„é¢œè‰²
                    ctx.beginPath();
                    ctx.arc(point.x, point.y, 4, 0, 2 * Math.PI); // ç»˜åˆ¶å°åœ†åœˆè¡¨ç¤ºç‚¹
                    ctx.fill();

                    // æ˜¾ç¤ºç‚¹çš„ç¼–å·
                    ctx.fillStyle = '#000000'; // ç¼–å·é¢œè‰²
                    ctx.font = '12px Arial';
                    ctx.fillText(`P${i + 1}`, point.x + 5, point.y - 5); // åœ¨ç‚¹æ—è¾¹æ˜¾ç¤ºç‚¹çš„ç¼–å·
                });

                // ç»˜åˆ¶å¤šè¾¹å½¢ç¼–å·
                const centerX = polygon.reduce((sum, p) => sum + p.x, 0) / polygon.length;
                const centerY = polygon.reduce((sum, p) => sum + p.y, 0) / polygon.length;
                ctx.fillStyle = '#00ff00'; // ç¼–å·é¢œè‰²
                ctx.font = '16px Arial';
                ctx.fillText(index + 1, centerX, centerY);
            });

            // ç»˜åˆ¶æ­£åœ¨ç»˜åˆ¶çš„å¤šè¾¹å½¢
            if (currentPoints.length > 0) {
                ctx.beginPath();
                ctx.moveTo(currentPoints[0].x, currentPoints[0].y); // èµ·å§‹ç‚¹
                currentPoints.forEach((point, index) => {
                    if (index > 0) ctx.lineTo(point.x, point.y); // è¿çº¿åˆ°ä¸‹ä¸€ä¸ªç‚¹
                });
                ctx.strokeStyle = '#ff0000'; // çº¢è‰²è¾¹çº¿
                ctx.lineWidth = 2; // è¾¹çº¿å®½åº¦
                ctx.stroke();

                // ç»˜åˆ¶æ­£åœ¨ç»˜åˆ¶çš„ç‚¹
                currentPoints.forEach((point, index) => {
                    // æ ‡æ³¨ç‚¹çš„ä½ç½®
                    ctx.fillStyle = '#ff0000'; // ç‚¹çš„é¢œè‰²
                    ctx.beginPath();
                    ctx.arc(point.x, point.y, 4, 0, 2 * Math.PI); // ç»˜åˆ¶å°åœ†åœˆè¡¨ç¤ºç‚¹
                    ctx.fill();

                    // æ˜¾ç¤ºç‚¹çš„ç¼–å·
                    ctx.fillStyle = '#000000'; // ç¼–å·é¢œè‰²
                    ctx.font = '12px Arial';
                    ctx.fillText(`P${index + 1}`, point.x + 5, point.y - 5); // åœ¨ç‚¹æ—è¾¹æ˜¾ç¤ºç‚¹çš„ç¼–å·
                });
            }

            // æ›´æ–°å¤šè¾¹å½¢åˆ—è¡¨
            updatePolygonList();
        }

        function updatePolygonList() {
            const list = document.getElementById('polygonListContent');
            const currentAnnotations = imageAnnotations[getCurrentImageName()] || [];
            list.innerHTML = currentAnnotations.map((polygon, index) => 
                `<div>
                    å¤šé‚Šå½¢ ${index + 1}: ${polygon.length} å€‹é ‚é»
                    <button onclick="deletePolygon(${index})">åˆªé™¤</button>
                </div>`
            ).join('');
        }

        function deletePolygon(index) {
            const imageName = getCurrentImageName();
            if (imageAnnotations[imageName]) {
                imageAnnotations[imageName].splice(index, 1);
                drawImage();
            }
        }

        canvas.addEventListener('click', function(event) {
            if (!getCurrentImage()) return;

            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = (event.clientX - rect.left) * scaleX;
            const y = (event.clientY - rect.top) * scaleY;

            if (currentTool === 'hexagon') {
                // ç¹ªè£½å…­é ‚é»å½¢ç‹€
                if (currentPoints.length < 6) {
                    currentPoints.push({ x, y });
                    if (currentPoints.length === 6) {
                        // ç•¶6é»å®Œæˆå¾Œï¼Œè‡ªå‹•åŠ å…¥è‡³è¨»è§£
                        const imageName = getCurrentImageName();
                        if (!imageAnnotations[imageName]) {
                            imageAnnotations[imageName] = [];
                        }
                        imageAnnotations[imageName].push([...currentPoints]);
                        currentPoints = [];
                        drawImage();
                    }
                }
                drawImage();
            } else if (currentTool === 'polygon') {
                // åŸæœ‰å¤šé‚Šå½¢ç¹ªè£½é‚è¼¯
                if (currentPoints.length > 0) {
                    const firstPoint = currentPoints[0];
                    const distance = Math.sqrt(
                        Math.pow(x - firstPoint.x, 2) + Math.pow(y - firstPoint.y, 2)
                    );
                    if (distance < 10) {
                        finishPolygon();
                        return;
                    }
                }
                currentPoints.push({ x, y });
                document.getElementById('finishBtn').disabled = currentPoints.length < 3;
                drawImage();
            } else if (currentTool === 'eraser') {
                // åŸæœ‰æ“¦é™¤é‚è¼¯
                const imageName = getCurrentImageName();
                const annotations = imageAnnotations[imageName];
                if (annotations) {
                    for (let i = annotations.length - 1; i >= 0; i--) {
                        if (isPointInPolygon({ x, y }, annotations[i])) {
                            annotations.splice(i, 1);
                            break;
                        }
                    }
                    drawImage();
                }
            }
        });


        function isPointInPolygon(point, polygon) {
            let inside = false;
            for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                const xi = polygon[i].x, yi = polygon[i].y;
                const xj = polygon[j].x, yj = polygon[j].y;
                
                const intersect = ((yi > point.y) !== (yj > point.y))
                    && (point.x < (xj - xi) * (point.y - yi) / (yj - yi) + xi);
                if (intersect) inside = !inside;
            }
            return inside;
        }

        function finishPolygon() {
            if (currentPoints.length >= 3) {
                const imageName = getCurrentImageName();
                if (!imageAnnotations[imageName]) {
                    imageAnnotations[imageName] = [];
                }
                imageAnnotations[imageName].push([...currentPoints]);
                currentPoints = [];
                document.getElementById('finishBtn').disabled = true;
                drawImage();
            }
        }

        function handleUndo() {
            if (currentPoints.length > 0) {
                currentPoints.pop();
                document.getElementById('finishBtn').disabled = currentPoints.length < 3;
                drawImage();
            } else {
                const imageName = getCurrentImageName();
                const annotations = imageAnnotations[imageName];
                if (annotations && annotations.length > 0) {
                    annotations.pop();
                    drawImage();
                }
            }
        }

        async function handleSaveAll() {
            const zip = new JSZip();

            const getBase64 = (img) => {
                const canvas = document.createElement('canvas');
                canvas.width = img.width;
                canvas.height = img.height;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0);
                return canvas.toDataURL('image/jpeg').split(',')[1];
            };

            images.forEach(image => {
                const annotations = imageAnnotations[image.name] || [];
                if (annotations.length > 0) {
                    const labelmeFormat = {
                        version: "5.0.1",
                        flags: {},
                        shapes: annotations.map((polygon, index) => ({
                            label: "spine",
                            points: polygon.map(p => [Math.round(p.x), Math.round(p.y)]),
                            group_id: null,
                            shape_type: "polygon",
                            flags: {}
                        })),
                        imageData: getBase64(image.img),
                        imagePath: image.name,
                        imageHeight: image.img.height,
                        imageWidth: image.img.width
                    };

                    const jsonFilename = image.name.replace(/\.[^/.]+$/, ".json");
                    zip.file(jsonFilename, JSON.stringify(labelmeFormat, null, 2));
                }
            });

            try {
                // ç”ŸæˆZIPæ–‡ä»¶
                const blob = await zip.generateAsync({ type: "blob" });

                // ä½¿ç”¨File System Access APIä¿å­˜æ–‡ä»¶
                if ('showSaveFilePicker' in window) {
                    const options = {
                        types: [
                            {
                                description: 'ZIP File',
                                accept: { 'application/zip': ['.zip'] },
                            },
                        ],
                    };

                    // æ˜¾ç¤ºä¿å­˜æ–‡ä»¶å¯¹è¯æ¡†
                    const fileHandle = await window.showSaveFilePicker(options);

                    // åˆ›å»ºå¯å†™çš„æ–‡ä»¶
                    const writableStream = await fileHandle.createWritable();
                    await writableStream.write(blob);
                    await writableStream.close();
                } else {
                    // å¦‚æœæµè§ˆå™¨ä¸æ”¯æŒ File System Access APIï¼Œä½¿ç”¨é»˜è®¤ä¸‹è½½
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = 'annotations.zip';
                    a.click();
                    URL.revokeObjectURL(url);
                }
            } catch (error) {
                console.error('Error saving annotations:', error);
                alert('Error saving annotations. Please try again.');
            }
        }



        function navigateImage(direction) {
            const newIndex = currentImageIndex + direction;
            if (newIndex >= 0 && newIndex < images.length) {
                currentPoints = [];  // åˆ‡æ›åœ–ç‰‡æ™‚æ¸…é™¤ç•¶å‰ç¹ªè£½çš„é»
                currentImageIndex = newIndex;
                drawImage();
                updateUI();
            }
        }

        function updateUI() {
            const hasImages = images.length > 0;
            document.getElementById('undoBtn').disabled = !hasImages;
            document.getElementById('saveBtn').disabled = !hasImages;
            document.getElementById('prevBtn').disabled = currentImageIndex === 0;
            document.getElementById('nextBtn').disabled = currentImageIndex === images.length - 1;
            document.getElementById('finishBtn').disabled = currentPoints.length < 3;
            
            if (hasImages) {
                document.getElementById('imageInfo').textContent = 
                    `${getCurrentImageName()} (${currentImageIndex + 1} / ${images.length})`;
            } else {
                document.getElementById('imageInfo').textContent = '';
            }
        }

        // åˆå§‹åŒ–å·¥å…·ç‹€æ…‹
        toggleTool('polygon');
    </script>
</body>
</html>